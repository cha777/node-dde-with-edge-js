// TimelinePlayer.js
// (c) 2013 thunder9 (https://github.com/thunder9)
// TimelinePlayer may be freely distributed under the MIT license.

(function(root) {

  // Baseline setup
  // --------------

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._ || require('underscore');

  // TimelinePlayer
  // --------------

  // Creating an instance of the `TimelinePlayer` that fires given callback 
  // at the positions on a timeline specified by `sequence` (an array 
  // of `[position, values]` pairs).
  var TimelinePlayer = function(sequence, callback) {
    this.sequence = _.isArray(sequence) ? sequence : [];
    this.callback = _.isFunction(callback) ? callback : function() {};
    this.position = 0;
    this._speed = 1;
    this._muted = false;
    players.push(this);
  };

  // Define the TimelinePlayer's inheritable methods.
  _.extend(TimelinePlayer.prototype, {

    // Starts a playback. If `pos` and/or **positive** `speed` are given, updates 
    // current position and/or speed respectively before starting the playback.
    play: function(pos, speed) {
      if (this._timeout) this.stop();
      if (_.isNumber(pos)) this.position = pos;
      if (speed > 0) this._speed = speed;
      this._startPosition = this.position;
      this._startTime = Date.now();
      this._timeout = null;
      schedule(this);
    },

    // Stop current playback and set current position to zero.
    stop: function() {
      this.pause();
      this.position = 0;
    },

    // Pauses current playback and update current position based on the elapsed time.
    pause: function() {
      if (this._timeout) clearTimeout(this._timeout);
      this._timeout = null;
      var elapsed = Date.now() - this._startTime;
      this.position = this._startPosition + elapsed * this._speed;
    },

    // Set speed of current playback. If `speed` is zero, negative or non-number, 
    // stop current playback immediately.
    setSpeed: function(speed) {
      if (!(speed > 0)) {
        this.stop();
        return;
      }
      if (this._timeout) {
        this.pause();
        this.play(null, speed);
      } else {
        this._speed = speed;
      }
    },

    // Mute firing
    mute: function() {
      this._muted = true;
    },

    // Unmute firing
    unmute: function() {
      this._muted = false;
    }

  });

  // Internal method called when fires the timed events.
  var schedule = function(state) {
    var previous = state.position;
    var elapsed = Date.now() - state._startTime;
    state.position = state._startPosition + elapsed * state._speed;
    
    var next = _.find(state.sequence, function(v) { return v[0] > state.position; });
    if (next) {
      var wait = (next[0] - state.position) / state._speed;
      state._timeout = setTimeout(schedule, wait, state);
    }

    if (!state._muted) {
      var f = previous === state.position
        ? function(v) { return v[0] === state.position; }
        : function(v) { return v[0] > previous && v[0] <= state.position; };
      _.each(_.filter(state.sequence, f), function(v) { state.callback.call(state, state.position, v); });
    }
  };

  // Array of TimelinePlayer's instances.
  var players = [];

  // Define the TimelinePlayer's static methods for global control.
  _.each(_.keys(TimelinePlayer.prototype), function(method) {
    TimelinePlayer[method] = function() {
      var args = _.toArray(arguments);
      _.each(players, function(player) { player[method].apply(player, args); } );
    }
  });

  // Exports the `TimelinePlayer`
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = TimelinePlayer;
    }
    exports.TimelinePlayer = TimelinePlayer;
  } else {
    root.TimelinePlayer = TimelinePlayer;
  }

})(this);
