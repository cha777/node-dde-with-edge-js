// Stepmachine.js 0.0.1
// (c) 2013 thunder9 (https://github.com/thunder9)
// Stepmachine may be freely distributed under the MIT license.

(function(root) {

  // Baseline setup
  // --------------

  // The top-level namespace. All public Stepmachine classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Stepmachine;
  if (typeof exports !== 'undefined') {
    Stepmachine = exports;
  } else {
    Stepmachine = root.Stepmachine = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Stepmachine.VERSION = '0.0.1';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._ || require('underscore');

  // Stepmachine.create
  // ------------------

  // Create an array of `[position, values]` pairs (called `stepmachine` in this 
  // library) from the given array (`input`) that defines a pattern of sequence.
  // Rules for defining a pattern of sequence in Stepmachine are followings:
  // 
  // [1] Elements of an array are positioned equally spaced. In other words, 
  //     the duration of an array is divided by a length of the array and the 
  //     result is assigned to the duration of child elements.
  // 
  //     Example: [ 'a', 'b' ]
  //              -> [ [0,['a']], [0.5,['b']] ]
  //
  // [2] Duration of a nested array equals to the duration of one element of 
  //     a parent array.
  // 
  //     Example: [ 'a', [ 'b', 'c' ] ]
  //                     ~~~~~~~~~~~~
  //              -> [ [0,['a']], [0.5,['b']], [0.75,['c']] ]
  // 
  // [3] Elements of an array having a parent array whose length is 1 are 
  //     parallelized.
  // 
  //     Example: [ 'a', [[ 'b', [ 'c' , 'd' ] ]]
  //                     ~~                    ~~
  //              -> [ [0,['a']], [0.5,['b','c']], [0.75,['d']] ]
  // 
  // If `duration` is given, the duration of the top-level array is set to this 
  // value (default is 1). If `start` is given, start position is set to this value 
  // (default is zero).
  Stepmachine.create = function(input, duration, start) {
    if (!_.isArray(input)) return;
    if (!_.isNumber(duration)) duration = 1;
    if (!_.isNumber(start)) start = 0;

    return _.chain(create(input, duration, start, []))
      .groupBy('pos')
      .pairs()
      .map(function(v) { return [+v[0], _.pluck(v[1], 'val')]; })
      .sortBy(function(v) { return v[0]; })
      .value();
  };

  // Internal implementation of a recursive `create` function.
  var create = function(input, duration, start, output) {
    var step = duration / input.length;
    if (input.length === 1 && _.isArray(input[0])) {
      step = duration;
      input = input[0];
    }
    _.each(input, function(value, index) {
      var pos = start + (step < duration ? index * step : 0);
      if (_.isArray(value)) {
        create(value, step, pos, output);
      } else if (value) {
        output.push({ pos: pos, val: value });
      }
    });
    return output;
  };

  // Mixing in the `Stepmachine.create` to Underscore named `stepmachine`
  _.mixin({ stepmachine: Stepmachine.create });

  // Stepmachine.reverse
  // -------------------

  // Reverses the elements of a given nested array excluding parallelized elements.
  Stepmachine.reverse = function(input) {
    return reverse(input);
  };  

  // Internal implementation of a recursive `reverse` function.
  var reverse = function(input) {
    if (!_.isArray(input)) return input;
    var output, buffer;
    input = input.slice(0);
    if (input.length === 1 && _.isArray(input[0])) {
      input = input[0].slice(0);
      buffer = (output = [input])[0];
    } else {
      buffer = output = input.reverse();
    }
    _.each(buffer, function(value, index) {
      buffer[index] = reverse(value);
    });
    return output;
  };

  // Mixing in the `Stepmachine.reverse` to Underscore
  _.mixin({ reverse: Stepmachine.reverse });

  // Stepmachine.cycle
  // -----------------

  // Returns an array built from the contents of a given array repeated
  // a certain number of times. If `alternate` is true, reverses the contents
  // of odd repetitions.
  Stepmachine.cycle = function(input, times, alternate) {
    var reversed = alternate ? reverse(input) : input;
    var cycled = [], i = 0;
    while (i < times) cycled.push(i++ % 2 === 0 ? input : reversed);
    return _.flatten(cycled, true);
  };  

  // Mixing in the `Stepmachine.cycle` to Underscore
  _.mixin({ cycle: Stepmachine.cycle });

})(this);
